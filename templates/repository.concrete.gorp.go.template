{{$resourceNameLower := .NameWithLowerFirst}}
{{$resourceNameUpper := .NameWithUpperFirst}}
package gorp

{{.Imports}}

// Generated by the goblimey scaffold generator.  You are STRONGLY
// recommended not to alter this file, as it will be overwritten next time the 
// scaffolder is run.  For the same reason, do not commit this file to a 
// source code repository.  Commit the json specification which was used to 
// produce it.

// This package satisfies the {{.NameWithLowerFirst}} Repository interface and
// provides Create, Read, Update and Delete (CRUD) operations on the {{.PluralNameWithLowerFirst}} resource.
// In this case, the resource is a MySQL table accessed via the GORP ORM.

type GorpMysqlRepository struct {
	dbmap *gorp.DbMap
	verbose bool
}

// MakeRepository is a factory function that creates a GorpMysqlRepository and 
// returns it as a Repository.
func MakeRepository(verbose bool) ({{.NameWithLowerFirst}}Repo.Repository, error) {
	log.SetPrefix("{{.PluralNameWithLowerFirst}}.MakeRepository() ")

	db, err := sql.Open("{{.DB}}", "{{.DBURL}}")
	if err != nil {
		log.Printf("failed to get DB handle - %s\n" + err.Error())
		return nil, errors.New("failed to get DB handle - " + err.Error())
	}
	// check that the handle works
	err = db.Ping()
	if err != nil {
		log.Printf("cannot connect to DB.  %s\n", err.Error())
		return nil, err
	}
	// construct a gorp DbMap
	dbmap := &gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{"InnoDB", "UTF8"}}
	table := dbmap.AddTableWithName(gorp{{.NameWithUpperFirst}}.Concrete{{.NameWithUpperFirst}}{}, "{{.TableName}}").SetKeys(true, "IDField")
	if table == nil {
		em := "cannot add table {{.TableName}}"
		log.Println(em)
		return nil, errors.New(em)
	}

	table.ColMap("IDField").Rename("id")
	{{range .Fields}}
	table.ColMap("{{.NameWithUpperFirst}}Field").Rename("{{.NameWithLowerFirst}}")
	{{end}}
	// Create any missing tables.
	err = dbmap.CreateTablesIfNotExists()
	if err != nil {
		em := fmt.Sprintf("cannot create table - %s\n", err.Error())
		log.Printf("em")
		return nil, errors.New(em)
	}
	
	repository := GorpMysqlRepository{dbmap, verbose}
	return repository, nil
}

// SetVerbosity sets the verbosity level.
func (gmpd GorpMysqlRepository) SetVerbosity(verbose bool) {
	gmpd.verbose = verbose
}

// FindAll returns a list of all valid {{.NameWithUpperFirst}} records from the database in a slice.
// The result may be an empty slice.  If the database lookup fails, the error is
// returned instead.
func (gmpd GorpMysqlRepository) FindAll() ([]{{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}, error) {
	log.SetPrefix("FindAll() ")
	if gmpd.verbose {
		log.Println("")
	}

	transaction, err := gmpd.dbmap.Begin()
	if err != nil {
		em := fmt.Sprintf("cannot create transaction - %s", err.Error())
		log.Println(em)
		return nil, errors.New(em)
	}
	var {{.NameWithLowerFirst}}List []gorp{{.NameWithUpperFirst}}.Concrete{{.NameWithUpperFirst}}
	
	_, err = transaction.Select(&{{.NameWithLowerFirst}}List,
		"select id, {{range .Fields}}{{.NameWithLowerFirst}}{{if not .LastItem}}, {{end}}{{end}} from {{.TableName}}")
	if err != nil {
		transaction.Rollback()
		return nil, err
	}
	transaction.Commit()

	valid{{.PluralNameWithUpperFirst}} := make([]{{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}, len({{.NameWithLowerFirst}}List))

	// Validate and clone the {{.NameWithUpperFirst}} records

	next := 0 // Index of next valid{{.PluralNameWithUpperFirst}} entry
	for i, _ := range {{.NameWithLowerFirst}}List {
		// Check any mandatory string fields
		{{range .Fields}}
			{{if eq .Type "string" }}
				{{$resourceNameLower}}List[i].Set{{.NameWithUpperFirst}}(strings.TrimSpace({{$resourceNameLower}}List[i].{{.NameWithUpperFirst}}()))
			{{end}}
			{{if .Mandatory}}
				{{if eq .Type "string" }}
					if len({{$resourceNameLower}}List[i].{{.NameWithUpperFirst}}()) == 0 {
						continue
					}
				{{end}}
			{{end}}
		{{end}}
		
		// All mandatory string fields are set.  Clone the data.
		valid{{.PluralNameWithUpperFirst}}[next] = gorp{{.NameWithUpperFirst}}.Clone(&{{.NameWithLowerFirst}}List[i])
		next++
	}

	return valid{{.PluralNameWithUpperFirst}}, nil
}

// FindByID fetches the row from the {{.TableName}} table with the given uint64 id. It
// validates that data and, if it's valid, returns the {{.NameWithLowerFirst}}.  If the data is not
// valid the function returns an error message.
func (gmpd GorpMysqlRepository) FindByID(id uint64) ({{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}, error) {
	log.SetPrefix("FindByID() ")
	if gmpd.verbose{
		log.Printf("id=%d", id)
	}

	var {{.NameWithLowerFirst}} gorp{{.NameWithUpperFirst}}.Concrete{{.NameWithUpperFirst}}
	transaction, err := gmpd.dbmap.Begin()
	if err != nil {
		em := fmt.Sprintf("cannot create transaction - %s", err.Error())
		log.Println(em)
		return nil, errors.New(em)
	}

	err = transaction.SelectOne(&{{.NameWithLowerFirst}},
		"select id, {{range .Fields}}{{.NameWithLowerFirst}}{{if not .LastItem}}, {{end}}{{end}} from {{.TableName}} where id = ?", id)
	if err != nil {
		transaction.Rollback()
		log.Println(err.Error())
		return nil, err
	}
	transaction.Commit()
	if gmpd.verbose {
		log.Printf("found {{.NameWithLowerFirst}} %s", {{.NameWithLowerFirst}}.String())
	}
	
	if err != nil {
		return nil, err
	}
	{{range .Fields}}
		{{if eq .Type "string" }}
			if len(strings.TrimSpace({{$resourceNameLower}}.{{.NameWithUpperFirst}}())) < 1 {
				return nil, errors.New("invalid {{$resourceNameLower}} - {{.NameWithLowerFirst}} field must be set")
			}
		{{end}}
	{{end}}
	return &{{.NameWithLowerFirst}}, nil
}

// FindByIDStr fetches the row from the {{.TableName}} table with the given string id. It
// validates that data and, if it's valid, returns the {{.NameWithLowerFirst}}.  If the data is not valid
// the function returns an errormessage.  The ID in the database is numeric and the method
// checks that the given ID is also numeric before it makes the call.  This avoids hitting
// the DB when the id is obviously junk.
func (gmpd GorpMysqlRepository) FindByIDStr(idStr string) ({{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}, error) {
	log.SetPrefix("FindByIDStr() ")
	if gmpd.verbose {
		log.Printf("id=%s", idStr)
	}

	id, err := strconv.ParseUint(idStr, 10, 64)
	if err != nil {
		em := fmt.Sprintf("ID %s is not an unsigned integer", idStr)
		log.Println(em)
		return nil, fmt.Errorf("ID %s is not an unsigned integer", idStr)
	}
	return gmpd.FindByID(id)
}

// Create takes a {{.NameWithLowerFirst}}, creates a record in the {{.TableName}} table containing the same
// data with an auto-incremented ID and returns any error that the DB call returns.
// On a successful create, the method returns the created {{.NameWithLowerFirst}}, including
// the assigned ID.  This is all done within a transaction to ensure atomicity.
func (gmpd GorpMysqlRepository) Create({{.NameWithLowerFirst}} {{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}) ({{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}, error) {
	log.SetPrefix("Create() ")
	if gmpd.verbose {
		log.Println("")
	}

	tx, err := gmpd.dbmap.Begin()
	if err != nil {
		log.Println(err.Error())
		return nil, err
	}
	{{.NameWithLowerFirst}}.SetID(0) // provokes the auto-increment
	err = tx.Insert({{.NameWithLowerFirst}})
	if err != nil {
		tx.Rollback()
		return nil, err
	}

	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		return nil, err
	}

	if gmpd.verbose {
		log.Printf("created {{.NameWithLowerFirst}} %s", {{.NameWithLowerFirst}}.String())
	}
	return {{.NameWithLowerFirst}}, nil
}

// Update takes a {{.NameWithLowerFirst}} record, updates the record in the {{.TableName}} table with the same ID
// and returns the updated {{.NameWithLowerFirst}} or any error that the DB call supplies to it.  The update
// is done within a transaction
func (gmpd GorpMysqlRepository) Update({{.NameWithLowerFirst}} {{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}) (uint64, error) {
	log.SetPrefix("Update() ")

	tx, err := gmpd.dbmap.Begin()
	if err != nil {
		log.Println(err.Error())
		return 0, err
	}
	rowsUpdated, err := tx.Update({{.NameWithLowerFirst}})
	if err != nil {
		tx.Rollback()
		log.Println(err.Error())
		return 0, err
	}
	if rowsUpdated != 1 {
		tx.Rollback()
		em := fmt.Sprintf("update failed - %d rows would have been updated, expected 1", rowsUpdated)
		log.Println(em)
		return 0, errors.New(em)
	}

	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		log.Println(err.Error())
		return 0, err
	}

	// Success!
	return 1, nil
}

// DeleteByID takes the given uint64 ID and deletes the record with that ID from the {{.TableName}} table.
// The function returns the row count and error that the database supplies to it.  On a successful
// delete, it should return 1, having deleted one row.
func (gmpd GorpMysqlRepository) DeleteByID(id uint64) (int64, error) {
	log.SetPrefix("DeleteByID() ")
	
	if gmpd.verbose {
		log.Printf("id=%d", id)
	}

	// Need a {{.NameWithUpperFirst}} record for the delete method, so fake one up.
	var {{.NameWithLowerFirst}} gorp{{.NameWithUpperFirst}}.Concrete{{.NameWithUpperFirst}}
	{{.NameWithLowerFirst}}.SetID(id)
	tx, err := gmpd.dbmap.Begin()
	if err != nil {
		log.Println(err.Error())
		return 0, err
	}
	rowsDeleted, err := tx.Delete(&{{.NameWithLowerFirst}})
	if err != nil {
		tx.Rollback()
		log.Println(err.Error())
		return 0, err
	}
	if rowsDeleted != 1 {
		tx.Rollback()
		em := fmt.Sprintf("delete failed - %d rows would have been deleted, expected 1", rowsDeleted)
		log.Println(em)
		return 0, errors.New(em)
	}

	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		log.Println(err.Error())
		return 0, err
	}
	if err != nil {
		log.Println(err.Error())
	}
	return rowsDeleted, nil
}

// DeleteByIDStr takes the given String ID and deletes the record with that ID from the {{.TableName}} table.
// The ID in the database is numeric and the method checks that the given ID is also numeric before
// it makes the call.  If not, it returns an error.  If the ID looks sensible, the function attempts
// the delete and returns the row count and error that the database supplies to it.  On a successful
// delete, it should return 1, having deleted one row.
func (gmpd GorpMysqlRepository) DeleteByIDStr(idStr string) (int64, error) {
	log.SetPrefix("DeleteByIDStr() ")
	if gmpd.verbose {
		log.Printf("ID %s", idStr)
	}
	// Check the id.
	id, err := strconv.ParseUint(idStr, 10, 64)
	if err != nil {
		em := fmt.Sprintf("ID %s is not an unsigned integer", idStr)
		log.Println(em)
		return 0, errors.New(em)
	}
	return gmpd.DeleteByID(id)
}

// Close closes the repository, reclaiming any redundant resources, in
// particular, any open database connection and transactions.  Anything that
// creates a repository MUST call this when it's finished, to avoid resource 
// leaks.
func (gmpd GorpMysqlRepository) Close() {
	log.SetPrefix("Close() ")
	if gmpd.verbose {	
		log.Printf("closing the {{.NameWithLowerFirst}} repository")
	}
	gmpd.dbmap.Db.Close()
}
