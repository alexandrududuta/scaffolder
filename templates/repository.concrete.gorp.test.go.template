{{$resourceNameLower := .NameWithLowerFirst}}
{{$resourceNameUpper := .NameWithUpperFirst}}
package gorp

{{.Imports}}

// Generated by the goblimey scaffold generator.  You are STRONGLY
// recommended not to alter this file, as it will be overwritten next time the 
// scaffolder is run.  For the same reason, do not commit this file to a 
// source code repository.  Commit the json specification which was used to 
// produce it.

// Integration tests for the Gorp MySQL {{.NameWithLowerFirst}} repository.

{{/* This creates the expected values using the field names and the test 
     values, something like:
	 var expectedName1 string = "s1"
	 var expectedAge1 int = 2 
	 var expectedName2 string = "s3"
	 var expectedAge2 int = 4 */}}
{{range $index, $element := .Fields}}
	{{if eq .Type "string"}}
		var expected{{.NameWithUpperFirst}}1 {{.GoType}} = "{{index .TestValues 0}}"
	{{else}}
		var expected{{.NameWithUpperFirst}}1 {{.GoType}} = {{index .TestValues 0}}
	{{end}}
	{{if eq .Type "string"}}
		var expected{{.NameWithUpperFirst}}2 {{.GoType}} = "{{index .TestValues 1}}"
	{{else}}
		var expected{{.NameWithUpperFirst}}2 {{.GoType}} = {{index .TestValues 1}}
	{{end}}
{{end}}

// Create a {{.NameWithLowerFirst}} in the database, read it back, test the contents.
func TestIntCreate{{.NameWithUpperFirst}}StoreFetchBackAndCheckContents(t *testing.T) {
	log.SetPrefix("TestIntegrationegrationCreate{{.NameWithUpperFirst}}AndCheckContents")

	// Create a GORP {{.PluralNameWithLowerFirst}} repository
	repository, err := MakeRepository(false)
	if err != nil {
		log.Println(err.Error())
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(-1)
	}
	defer repository.Close()

	clearDown(repository, t)
	
	o := gorp{{.NameWithUpperFirst}}.MakeInitialised{{.NameWithUpperFirst}}(0, {{range .Fields}}expected{{.NameWithUpperFirst}}1{{if not .LastItem}}, {{end}}{{end}})
	{{.NameWithLowerFirst}}, err := repository.Create(o)
	if err != nil {
		t.Errorf(err.Error())
	}

	retrieved{{.NameWithUpperFirst}}, err := repository.FindByID({{.NameWithLowerFirst}}.ID())
	if err != nil {
		t.Errorf(err.Error())
	}

	if retrieved{{.NameWithUpperFirst}}.ID() != {{.NameWithLowerFirst}}.ID() {
		t.Errorf("expected ID to be %d actually %d", {{.NameWithLowerFirst}}.ID(),
			retrieved{{.NameWithUpperFirst}}.ID())
	}
	{{range .Fields}}
		if retrieved{{$resourceNameUpper}}.{{.NameWithUpperFirst}}() != expected{{.NameWithUpperFirst}}1 {
			t.Errorf("expected {{.NameWithLowerFirst}} to be %s actually %s", expected{{.NameWithUpperFirst}}1, {{$resourceNameLower}}.{{.NameWithUpperFirst}}())
	}
	{{end}}

	// Delete {{.NameWithLowerFirst}} and check response
	rows, err := repository.DeleteByID(retrieved{{.NameWithUpperFirst}}.ID())
	if err != nil {
		t.Errorf(err.Error())
	}
	if rows != 1 {
		t.Errorf("expected delete to return 1, actual %d", rows)
	}
	clearDown(repository, t)
}

// Create two {{.NameWithLowerFirst}} records in the DB, read them back and check the fields
func TestIntCreateTwo{{.PluralNameWithUpperFirst}}AndReadBack(t *testing.T) {
	log.SetPrefix("TestCreate{{.NameWithUpperFirst}}AndReadBack")

	// Create a GORP {{.PluralNameWithLowerFirst}} repository
	repository, err := MakeRepository(false)
	if err != nil {
		log.Println(err.Error())
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(-1)
	}
	defer repository.Close()

	clearDown(repository, t)

	//Create two {{.PluralNameWithLowerFirst}}

	o1 := gorp{{.NameWithUpperFirst}}.MakeInitialised{{.NameWithUpperFirst}}(0, {{range .Fields}}expected{{.NameWithUpperFirst}}1{{if not .LastItem}}, {{end}}{{end}})
	{{.NameWithLowerFirst}}1, err := repository.Create(o1)
	if err != nil {
		t.Errorf(err.Error())
	}

	o2 := gorp{{.NameWithUpperFirst}}.MakeInitialised{{.NameWithUpperFirst}}(0, {{range .Fields}}expected{{.NameWithUpperFirst}}2{{if not .LastItem}}, {{end}}{{end}})
	{{.NameWithLowerFirst}}2, err := repository.Create(o2)
	if err != nil {
		t.Errorf(err.Error())
	}

	// read all the {{.PluralNameWithLowerFirst}} in the DB - expect just the two we created
	{{.PluralNameWithLowerFirst}}, err := repository.FindAll()
	if err != nil {
		t.Errorf(err.Error())
	}

	if len({{.PluralNameWithLowerFirst}}) != 2 {
		t.Errorf("expected 2 rows, actual %d", len({{.PluralNameWithLowerFirst}}))
	}

	for _, {{.NameWithLowerFirst}} := range {{.PluralNameWithLowerFirst}} {
		
		matches := 1
		
		{{/* Check that the fields of each are consistent with the source object.
		     (Note: we don't know what in order the two objects will come back.) */}}

			{{$firstField := index .Fields 0}}
			{{$firstFieldName := $firstField.NameWithUpperFirst}}
			switch {{.NameWithLowerFirst}}.{{$firstFieldName}}() {
			case expected{{$firstFieldName}}1:
				{{range .Fields}}
					{{if ne $firstFieldName .NameWithUpperFirst}}
						if {{$resourceNameLower}}.{{.NameWithUpperFirst}}() == expected{{.NameWithUpperFirst}}1 {
							matches++
						} else {
							t.Errorf("expected {{.NameWithLowerFirst}} to be %s actually %s", 
								expected{{.NameWithUpperFirst}}1, {{$resourceNameLower}}.{{.NameWithUpperFirst}}())
						}
					{{end}}
				{{end}}
			case expected{{$firstFieldName}}2:
				{{range .Fields}}
					{{if ne $firstFieldName .NameWithUpperFirst}}
						if {{$resourceNameLower}}.{{.NameWithUpperFirst}}() == expected{{.NameWithUpperFirst}}2 {
							matches++
						} else {
							t.Errorf("expected {{.NameWithLowerFirst}} to be %s actually %s", 
								expected{{.NameWithUpperFirst}}2, {{$resourceNameLower}}.{{.NameWithUpperFirst}}())
						}
					{{end}}
				{{end}}
			default:
				t.Errorf("unexpected {{.NameWithLowerFirst}} with name %s - expected %s or %s", 
					{{$resourceNameLower}}.{{$firstFieldName}}(), expected{{$firstFieldName}}1, expected{{$firstFieldName}}2)
			}
			
			// We should have one match for each field
			if matches != {{len .Fields}} {
				t.Errorf("expected %d fields, actual %d", {{len .Fields}}, matches)
			}
	}

	
	// Find the first {{.NameWithLowerFirst}} by numeric ID and check the fields
	{{.NameWithLowerFirst}}1Returned, err := repository.FindByID({{.NameWithLowerFirst}}1.ID())
	if err != nil {
		t.Errorf(err.Error())
	}

	{{range .Fields}}
		if {{$resourceNameLower}}1Returned.{{.NameWithUpperFirst}}() != expected{{.NameWithUpperFirst}}1 {
			t.Errorf("expected {{.NameWithLowerFirst}} to be %s actually %s",
				expected{{.NameWithUpperFirst}}1, {{$resourceNameLower}}1Returned.{{.NameWithUpperFirst}}())
		}
	{{end}}

	// Find the second {{.NameWithLowerFirst}} by string ID and check the fields
	IDStr := strconv.FormatUint({{.NameWithLowerFirst}}2.ID(), 10)
	{{.NameWithLowerFirst}}2Returned, err := repository.FindByIDStr(IDStr)
	if err != nil {
		t.Errorf(err.Error())
	}
	
	{{range .Fields}}
		if {{$resourceNameLower}}2Returned.{{.NameWithUpperFirst}}() != expected{{.NameWithUpperFirst}}2 {
			t.Errorf("expected {{.NameWithLowerFirst}} to be %s actually %s",
				expected{{.NameWithUpperFirst}}2, {{$resourceNameLower}}2Returned.{{.NameWithUpperFirst}}())
		}
	{{end}}

	clearDown(repository, t)
}

// Create two {{.PluralNameWithUpperFirst}}, remove one, check that we get back just the other
func TestIntCreateTwo{{.PluralNameWithUpperFirst}}AndDeleteOneByIDStr(t *testing.T) {
	log.SetPrefix("TestIntegrationegrationCreateTwoPeopleAndDeleteOneByIDStr")

	// Create a GORP {{.PluralNameWithLowerFirst}} repository
	repository, err := MakeRepository(false)
	if err != nil {
		log.Println(err.Error())
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(-1)
	}
	defer repository.Close()

	clearDown(repository, t)

	// Create two {{.PluralNameWithLowerFirst}}
	o1 := gorp{{.NameWithUpperFirst}}.MakeInitialised{{.NameWithUpperFirst}}(0, {{range .Fields}}expected{{.NameWithUpperFirst}}1{{if not .LastItem}}, {{end}}{{end}})
	{{.NameWithLowerFirst}}1, err := repository.Create(o1)
	if err != nil {
		t.Errorf(err.Error())
	}

	o2 := gorp{{.NameWithUpperFirst}}.MakeInitialised{{.NameWithUpperFirst}}(0, {{range .Fields}}expected{{.NameWithUpperFirst}}2{{if not .LastItem}}, {{end}}{{end}})
	{{.NameWithLowerFirst}}2, err := repository.Create(o2)
	if err != nil {
		t.Errorf(err.Error())
	}

	var IDStr = fmt.Sprintf("%d", {{.NameWithLowerFirst}}1.ID())
	rows, err := repository.DeleteByIDStr(IDStr)
	if err != nil {
		t.Errorf(err.Error())
	}
	if rows != 1 {
		t.Errorf("expected one record to be deleted, actually %d", rows)
	}

	// We should have one record in the DB and it should match {{.NameWithLowerFirst}}2
	{{.PluralNameWithLowerFirst}}, err := repository.FindAll()
	if err != nil {
		t.Errorf(err.Error())
	}

	if len({{.PluralNameWithLowerFirst}}) != 1 {
		t.Errorf("expected one record, actual %d", len({{.PluralNameWithLowerFirst}}))
	}

	if {{.PluralNameWithLowerFirst}}[0].ID() != {{.NameWithLowerFirst}}2.ID() {
		t.Errorf("expected id to be %d actually %d",
			{{.NameWithLowerFirst}}2.ID(), {{.PluralNameWithLowerFirst}}[0].ID())
	}
	{{$name := .PluralNameWithLowerFirst}}
	{{range .Fields}}
		if {{$name}}[0].{{.NameWithUpperFirst}}() != expected{{.NameWithUpperFirst}}2 {
			t.Errorf("expected {{.NameWithLowerFirst}} to be %s actually %s",
				expected{{.NameWithUpperFirst}}2, {{$name}}[0].{{.NameWithUpperFirst}}())
		}
	{{end}}

	clearDown(repository, t)
}

// Create a {{.NameWithLowerFirst}} record, update the record, read it back and check the updated values.
func TestIntCreate{{.NameWithUpperFirst}}AndUpdate(t *testing.T) {
	log.SetPrefix("TestIntCreate{{.NameWithUpperFirst}}AndUpdate")

	// Create a GORP {{.PluralNameWithLowerFirst}} repository
	repository, err := MakeRepository(false)
	if err != nil {
		log.Println(err.Error())
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(-1)
	}
	defer repository.Close()

	clearDown(repository, t)

	// Create a {{.NameWithLowerFirst}} in the DB.
	o := gorp{{.NameWithUpperFirst}}.MakeInitialised{{.NameWithUpperFirst}}(0, {{range .Fields}}expected{{.NameWithUpperFirst}}1{{if not .LastItem}}, {{end}}{{end}})
	{{.NameWithLowerFirst}}, err := repository.Create(o)
	if err != nil {
		t.Errorf(err.Error())
	}

	// Update the {{.NameWithLowerFirst}} in the DB.
	{{range .Fields}}
		{{$resourceNameLower}}.Set{{.NameWithUpperFirst}}(expected{{.NameWithUpperFirst}}2)
	{{end}}
	rows, err := repository.Update({{.NameWithLowerFirst}})
	if err != nil {
		t.Errorf(err.Error())
	}
	if rows != 1 {
		t.Errorf("expected 1 row to be updated, actually %d rows", rows)
	}

	// fetch the updated record back and check it.
	retrieved{{.NameWithUpperFirst}}, err := repository.FindByID({{.NameWithLowerFirst}}.ID())
	if err != nil {
		t.Errorf(err.Error())
	}

	{{range .Fields}}
		if retrieved{{$resourceNameUpper}}.{{.NameWithUpperFirst}}() != expected{{.NameWithUpperFirst}}2 {
			t.Errorf("expected {{.NameWithLowerFirst}} to be %s actually %s",
				expected{{.NameWithUpperFirst}}2, retrieved{{$resourceNameUpper}}.{{.NameWithUpperFirst}}())
		}
	{{end}}

	clearDown(repository, t)
}

// clearDown() - helper function to remove all {{.PluralNameWithLowerFirst}} from the DB
func clearDown(repository {{.NameWithLowerFirst}}.Repository, t *testing.T) {
	{{.PluralNameWithLowerFirst}}, err := repository.FindAll()
	if err != nil {
		t.Errorf(err.Error())
		return
	}
	for _, {{.NameWithLowerFirst}} := range {{.PluralNameWithLowerFirst}} {
		rows, err := repository.DeleteByID({{.NameWithLowerFirst}}.ID())
		if err != nil {
			t.Errorf(err.Error())
			continue
		}
		if rows != 1 {
			t.Errorf("while clearing down, expected 1 row, actual %d", rows)
		}
	}
}
