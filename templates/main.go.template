package main

{{.Imports}}

// Originally generated by the goblimey scaffold generator.  It is safe to edit
// this file.  If you need to restore the original version, run the scaffolder with 
// the -overwrite option.

// The {{.NameWithLowerFirst}} program provides the back end logic to provide
// CRUD operations on the {{.NameWithLowerFirst}} resources.

// resourceRE is the regular expression to extract the resource from the URI of
// the request to be.  For example in: "/people" and "/people/1/delete", the
// resource is "people".
var resourceRE = regexp.MustCompile(%%GRAVE%%^/([^/]+)%%GRAVE%%)

// The following regular expressions are for specific request URIs, to work out
// which controller method to call.  For example, a GET request with URI "/people"
// produces a call to the Index method of the people controller.
//
// The requests follow the REST model and therefore carry data such as IDs
// in the request URI rather than in HTTP parameters, for example:
//
//    GET /people/435
//
// rather than
//
//    GET/people&id=435
//
// Only form data is supplied through HTTP parameters

{{range .Resources}}
// The {{.NameWithLowerFirst}}DeleteRequestRE is the regular expression for the URI of a delete
// request containing a numeric ID - for example: "/{{.PluralNameWithLowerFirst}}/1/delete".
var {{.NameWithLowerFirst}}DeleteRequestRE = regexp.MustCompile(%%GRAVE%%^/{{.PluralNameWithLowerFirst}}/[0-9]+/delete$%%GRAVE%%)

// The {{.NameWithLowerFirst}}ShowRequestRE is the regular expression for the URI of a show
// request containing a numeric ID - for example: "/{{.PluralNameWithLowerFirst}}/1".
var {{.NameWithLowerFirst}}ShowRequestRE = regexp.MustCompile(%%GRAVE%%^/{{.PluralNameWithLowerFirst}}/[0-9]+$%%GRAVE%%)

// The {{.NameWithLowerFirst}}EditRequestRE is the regular expression for the URI of an edit
// request containing a numeric ID - for example: "/{{.PluralNameWithLowerFirst}}/1/edit".
var {{.NameWithLowerFirst}}EditRequestRE = regexp.MustCompile(%%GRAVE%%^/{{.PluralNameWithLowerFirst}}/[0-9]+/edit$%%GRAVE%%)

// The {{.NameWithLowerFirst}}UpdateRequestRE is the regular expression for the URI of an update
// request containing a numeric ID - for example: "/{{.PluralNameWithLowerFirst}}/1".  The URI
// is the same as for the show request, but we give it a different name for
// clarity.
var {{.NameWithLowerFirst}}UpdateRequestRE = {{.NameWithLowerFirst}}ShowRequestRE
{{end}}
var templateMap *map[string]map[string]retrofitTemplate.Template

// These values are set from the command line arguments.
var homeDir string // app server's home directory
var verbose bool   // verbose mode

func init() {
	const (
		defaultVerbose = false
		usage          = "enable verbose logging"
	)
	flag.BoolVar(&verbose, "verbose", defaultVerbose, usage)
	flag.BoolVar(&verbose, "v", defaultVerbose, usage+" (shorthand)")
	flag.StringVar(&homeDir, "homedir", ".", "the application server's home directory (must contain the views directory)")
}

func main() {
	log.SetPrefix("main() ")
	// Find the home directory.  This is specified by the first command line
	// argument.  If that's not specified, the home is assumed to be the current
	//directory.

	flag.Parse()
	if len(flag.Args()) >= 1 {
		homeDir = flag.Args()[0]
	}
	err := os.Chdir(homeDir)
	if err != nil {
		log.Printf("cannot change directory to homeDir %s - %s", homeDir,
			err.Error())
		os.Exit(-1)
	}

	// The home directory must contain a directory "views" containing the HTML and
	// the templates. If there is no views directory, give up.  Most likely, the
	// user has not moved to the right directory before running this.
	fileInfo, err := os.Stat("views")
	if err != nil {
		if os.IsNotExist(err) {
			// views does not exist
			em := "cannot find the views directory"
			log.Println(em)
			fmt.Fprintln(os.Stderr, em)

		} else if !fileInfo.IsDir() {
			// views exists but is not a directory
			em := "the file views must be a directory"
			log.Println(em)
			fmt.Fprintln(os.Stderr, em)

		} else {
			// some other error
			log.Println(err.Error())
			fmt.Fprintln(os.Stderr, err.Error())
		}

		os.Exit(-1)
	}

	templateMap = utilities.CreateTemplates()

	// Set up the restful web service.  Send all requests to marshal().

	if verbose {
		log.Println("setting up routes")
	}
	ws := new(restful.WebService)
	http.Handle("/stylesheets/", http.StripPrefix("/stylesheets/", http.FileServer(http.Dir("views/stylesheets"))))
	http.Handle("/html/", http.StripPrefix("/html/", http.FileServer(http.Dir("views/html"))))
	// Handlers for static HTML pages.

	ws.Route(ws.GET("/").To(marshal))
	ws.Route(ws.GET("/error.html").To(marshal))
{{range .Resources}}
	// Tie all expected requests to the marshal.
	ws.Route(ws.GET("/{{.PluralNameWithLowerFirst}}").To(marshal))
	ws.Route(ws.GET("/{{.PluralNameWithLowerFirst}}/{id}/edit").To(marshal))
	ws.Route(ws.GET("/{{.PluralNameWithLowerFirst}}/{id}").To(marshal))
	ws.Route(ws.GET("/{{.PluralNameWithLowerFirst}}/create").To(marshal))
	ws.Route(ws.POST("/{{.PluralNameWithLowerFirst}}").Consumes("application/x-www-form-urlencoded").To(marshal))
	ws.Route(ws.POST("/{{.PluralNameWithLowerFirst}}/{id}").Consumes("application/x-www-form-urlencoded").To(marshal))
	ws.Route(ws.POST("/{{.PluralNameWithLowerFirst}}/{id}/delete").Consumes("application/x-www-form-urlencoded").To(marshal))
{{end}}
	restful.Add(ws)

	if verbose {
		log.Println("starting the listener")
	}	
	err = http.ListenAndServe(":4000", nil)
	log.Printf("baling out - %s" + err.Error())
}

// marshal passes the request and response to the appropriate method of the
// appropriate  controller.
func marshal(request *restful.Request, response *restful.Response) {

	log.SetPrefix("main.marshal() ")

	defer catchPanic()
	
	// Create a service supplier
	var services services.ConcreteServices
	services.SetTemplates(templateMap)
{{range .Resources}}
	{{.NameWithUpperFirst}}Repository, err := {{.NameWithLowerFirst}}Repository.MakeRepository(verbose)
	if err != nil {
		log.Println(err.Error())
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(-1)
	}
	services.Set{{.NameWithUpperFirst}}Repository({{.NameWithUpperFirst}}Repository)
	defer {{.NameWithUpperFirst}}Repository.Close()
{{end}}

	// We get the HTTP request from the restful request via its public Request
	// attribute.  Getting the method from that requires another public attribute.
	// These operations and others cannot be defined using an interface, which is
	// why the request and response are passed to the controller as pointers to
	// concrete objects rather than as retro-fitted interfaces.

	uri := request.Request.URL.RequestURI()

	// The REST model uses HTTP requests such as PUT and DELETE.  The standard browsers do not support
	// these operations, so they are implemented using a POST request with a parameter "_method"
	// defining the operation.  (A post with a parameter "_method=PUT" simulates a PUT, and so on.)

	method := request.Request.Method
	if method == "POST" {
		// handle simulated PUT, DELETE etc via the _method parameter
		simMethod := request.Request.FormValue("_method")
		if simMethod == "PUT" || simMethod == "DELETE" {
			method = simMethod
		}
	}
	if verbose {
		log.Printf("uri %s method %s", uri, method)
	}
	
	// The home page "/" or "/index.html" is dealt with using the special resource 
	// "html".
	
	if uri == "/" || uri == "/index.html" {
		if verbose {
			log.Println("home page")
		}
		page := services.Template("html", "Index")
		if page == nil {
			log.Printf("no home Index page")
			utilities.Dead(response)
			return
		}
		// This template is just HTML, so it needs no data.
		err = page.Execute(response.ResponseWriter, nil)
		if err != nil {
			// Can't display the home index page.  Bale out.
			em := fmt.Sprintf("fatal error - failed to display error page for error %s\n", err.Error())
			log.Printf(em)
			panic(em)
		}
		return
	}
	
	// Extract the resource.  For uris "/people", /people/1 etc, the resource is
	// "people".  If the string matches the regular expression, result will have
	// at least two entries and the resource name will be in result[1]. 

	result := resourceRE.FindStringSubmatch(uri)

	if len(result) < 2 {
		em := fmt.Sprintf("illegal request uri %v", uri)
		log.Println(em)
		utilities.BadError(em, response)
		return
	}

	resource := result[1]

	switch resource {
{{range .Resources}}
	case "{{.PluralNameWithLowerFirst}}":

		if verbose {
			log.Printf("Sending request %s to {{.NameWithLowerFirst}} controller\n", uri)
		}
		
		var controller = {{.NameWithLowerFirst}}Controller.MakeController(&services, verbose)

		// Call the appropriate handler for the request

		switch method {

		case "GET":

			if uri == "/{{.PluralNameWithLowerFirst}}" {
				// "GET http://server:port/{{.PluralNameWithLowerFirst}}" - fetch all the valid {{.PluralNameWithLowerFirst}}
				// records and display them.
				form := services.Make{{.NameWithUpperFirst}}ListForm()
				controller.Index(request, response, form)

			} else if {{.NameWithLowerFirst}}EditRequestRE.MatchString(uri) {

				// "GET http://server:port/{{.PluralNameWithLowerFirst}}/1/edit" - fetch the {{.PluralNameWithLowerFirst}} record
				// given by the ID in the request and display the form to edit it.
				{{.NameWithLowerFirst}} := services.Make{{.NameWithUpperFirst}}()
				form := services.Make{{.NameWithUpperFirst}}Form()
				form.Set{{.NameWithUpperFirst}}({{.NameWithLowerFirst}})
				// The URI should contain an ID as a string.  Parse and copy it.
				var id uint64 = 0
				idStr := request.PathParameter("id")
				if verbose {
					log.Printf("id %s", idStr)
				}
				if idStr == "" {
					// This should never happen
					em := fmt.Sprintf("id is not set in the request, must be an unsigned integer")
					log.Printf("%s\n", em)
					form.SetErrorMessageForField("ID", "Internal error - " + em)
				}
					
				id, err = strconv.ParseUint(idStr, 10, 64)
				if err != nil {
					em := fmt.Sprintf("invalid id %s in request, must be an unsigned integer - %s", 
						idStr, err.Error())
					log.Printf("%s\n", em)
					form.SetErrorMessageForField("ID", "ID must be a whole number greater than 0")
				}
				{{.NameWithLowerFirst}}.SetID(id)
				
				controller.Edit(request, response, form)


			} else if uri == "/{{.PluralNameWithLowerFirst}}/create" {

				// "GET http://server:port/{{.PluralNameWithLowerFirst}}/create" - display the form to
				// create a new single item {{.NameWithLowerFirst}} record.

				// Create an empty {{.NameWithLowerFirst}} to get started.
				{{.NameWithLowerFirst}} := services.Make{{.NameWithUpperFirst}}()
				form := services.Make{{.NameWithUpperFirst}}Form()
				form.Set{{.NameWithUpperFirst}}({{.NameWithLowerFirst}})
				controller.New(request, response, form)


			} else if {{.NameWithLowerFirst}}ShowRequestRE.MatchString(uri) {

				// "GET http://server:port/{{.PluralNameWithLowerFirst}}/435" - fetch the {{.PluralNameWithLowerFirst}} record
				// with ID 435 and display it.
				
				// Get the ID from the HTML form data .  The data only contains the
				// ID so the resulting {{.NameWithUpperFirst}}Form may be marked 
				// as invalid, but we are only interested in the ID.
				{{.NameWithLowerFirst}} := services.Make{{.NameWithUpperFirst}}()
				form := services.Make{{.NameWithUpperFirst}}Form()
				form.Set{{.NameWithUpperFirst}}({{.NameWithLowerFirst}})
				
				// Get the ID from the request and create a form containing a
				// {{.NameWithLowerFirst}} with only the ID set.  The resulting 
				// form will be  invalid, but we are only interested in the ID.
				var id uint64 = 0
				idStr := request.PathParameter("id")
				if verbose {
					log.Printf("id %s", idStr)
				}
				if idStr == "" {
					// This should never happen
					em := fmt.Sprintf("id is not set in the request, must be an unsigned integer")
					log.Printf("%s\n", em)
					form.SetErrorMessageForField("ID", "Internal error - " + em)
				}
					
				id, err = strconv.ParseUint(idStr, 10, 64)
				if err != nil {
					em := fmt.Sprintf("invalid id %s in request, must be an unsigned integer - %s", 
						idStr, err.Error())
					log.Printf("%s\n", em)
					form.SetErrorMessageForField("ID", "ID must be a whole number greater than 0")
				}
				{{.NameWithLowerFirst}}.SetID(id)
				
				controller.Show(request, response, form)

				
			} else {
				em := fmt.Sprintf("unexpected GET request - uri %v", uri)
				log.Println(em)
				controller.ErrorHandler(request, response, em)
			}

		case "PUT":
			if {{.NameWithLowerFirst}}UpdateRequestRE.MatchString(uri) {

				// POST http://server:port/{{.PluralNameWithLowerFirst}}/1" - update the single item {{.NameWithLowerFirst}} record with
				// the given ID from the URI using the form data in the body.
				form := makeValidated{{.NameWithUpperFirst}}FormFromRequest(request, &services)
				controller.Update(request, response, form)

			} else if uri == "/{{.PluralNameWithLowerFirst}}" {

				// POST http://server:port/{{.PluralNameWithLowerFirst}}" - create a new {{.PluralNameWithLowerFirst}} record from
				// the form data in the body.
				form := makeValidated{{.NameWithUpperFirst}}FormFromRequest(request, &services)
				controller.Create(request, response, form)

			} else {
				em := fmt.Sprintf("unexpected PUT request - uri %v", uri)
				log.Println(em)
				controller.ErrorHandler(request, response, em)
			}

		case "DELETE":
			if {{.NameWithLowerFirst}}DeleteRequestRE.MatchString(uri) {

				// "POST http://server:port/{{.PluralNameWithLowerFirst}}/1/delete" - delete the {{.PluralNameWithLowerFirst}}
				// record with the ID given in the request.
				
				{{.NameWithLowerFirst}} := services.Make{{.NameWithUpperFirst}}()
				form := services.Make{{.NameWithUpperFirst}}Form()
				form.Set{{.NameWithUpperFirst}}({{.NameWithLowerFirst}})
				
				// Get the ID from the request and create a form containing a
				// {{.NameWithLowerFirst}} with only the ID set.  The resulting 
				// form will be  invalid, but we are only interested in the ID.
				var id uint64 = 0
				idStr := request.PathParameter("id")
				if verbose {
					log.Printf("id %s", idStr)
				}
				if idStr == "" {
					// This should never happen
					em := fmt.Sprintf("id is not set in the request, must be an unsigned integer")
					log.Printf("%s\n", em)
					form.SetErrorMessageForField("ID", "Internal error - " + em)
				}
					
				id, err = strconv.ParseUint(idStr, 10, 64)
				if err != nil {
					em := fmt.Sprintf("invalid id %s in request, must be an unsigned integer - %s", 
						idStr, err.Error())
					log.Printf("%s\n", em)
					form.SetErrorMessageForField("ID", "ID must be a whole number greater than 0")
				}
				{{.NameWithLowerFirst}}.SetID(id)
				
				controller.Delete(request, response, form)
			}

		default:
			em := fmt.Sprintf("unexpected HTTP method %v", method)
			log.Println(em)
			controller.ErrorHandler(request, response, em)
		}
{{end}}
	default:
		em := fmt.Sprintf("unexpected resource %v in uri %v", resource, uri)
		log.Println(em)
		utilities.BadError(em, response)
	}
}

{{$resourceNameLower := .NameWithLowerFirst}}
{{$resourceNameUpper := .NameWithUpperFirst}}
{{range .Resources}}
// makeValidated{{.NameWithUpperFirst}}FormFromRequest gets the {{.NameWithLowerFirst}} data from the request, creates a
// {{.NameWithUpperFirst}} and returns it in a single item {{.NameWithLowerFirst}} form.
func makeValidated{{.NameWithUpperFirst}}FormFromRequest(request *restful.Request, services services.Services) {{.NameWithLowerFirst}}Forms.SingleItemForm {

	log.SetPrefix("makeValidated{{.NameWithUpperFirst}}FormFromRequest() ")

	{{.NameWithLowerFirst}} := services.Make{{.NameWithUpperFirst}}()
	{{.NameWithLowerFirst}}Form := services.MakeInitialised{{.NameWithUpperFirst}}Form({{.NameWithLowerFirst}})
	
	// The Validate method validates the {{.NameWithUpperFirst}}Form. Fields
	//in the request that are destined for any object except a string could
	// also be invalid and we also have to check for that before we set
	// a field in the {{.NameWithUpperFirst}}Form.
	
	valid := true	// This will be set false on any error.
	
	err := request.Request.ParseForm()
	if err != nil {
		valid = false
		em := fmt.Sprintf("cannot parse form - %s", err.Error())
		log.Printf("%s\n", em)
		{{.NameWithLowerFirst}}Form.SetErrorMessage("Internal error while processing the last data input")
		// Cannot make any sense of the HTML form data - bale out.
		return {{.NameWithLowerFirst}}Form
	}
	
	// If the URI contains an ID, parse and copy it.
	var id uint64 = 0
	idStr := request.PathParameter("id")
	if idStr != "" {
		if verbose {
			log.Printf("id %s", idStr)
		}
		id, err = strconv.ParseUint(idStr, 10, 64)
		if err != nil {
			valid = false
			em := fmt.Sprintf("invalid id %s in request, must be an unsigned integer - %s", 
				idStr, err.Error())
			log.Printf("%s\n", em)
			{{.NameWithLowerFirst}}Form.SetErrorMessageForField("ID", "ID must be a whole number greater than 0")
		}
		{{.NameWithLowerFirst}}.SetID(id)
	}

{{$resourceNameLower := .NameWithLowerFirst}}
{{$resourceNameUpper := .NameWithUpperFirst}}
{{range .Fields}}
	{{if eq .GoType "string"}}
		{{.NameWithLowerFirst}} := request.FormValue("{{.NameWithLowerFirst}}")
		if verbose {
			log.Printf("{{.NameWithLowerFirst}} %s", {{.NameWithLowerFirst}})
		}
	{{else}}
		{{.NameWithLowerFirst}}Str := strings.TrimSpace(request.Request.FormValue("{{.NameWithLowerFirst}}"))
		if verbose {
			log.Printf("{{.NameWithLowerFirst}} %s", {{.NameWithLowerFirst}}Str)
		}
		{{if eq .GoType "int64"}}
			{{.NameWithLowerFirst}}, err := strconv.ParseInt({{.NameWithLowerFirst}}Str, 10, 64)
			if err != nil {
				valid = false
				log.Println(fmt.Sprintf("HTTP form input for field {{.NameWithLowerFirst}} %s is not an integer - %s", 
				    {{.NameWithLowerFirst}}Str, err.Error()))
				{{$resourceNameLower}}Form.SetErrorMessageForField("{{.NameWithUpperFirst}}", "must be a whole number")
			}
		{{else if eq .GoType "uint64"}}
			{{.NameWithLowerFirst}}, err := strconv.ParseUint({{.NameWithLowerFirst}}Str, 10, 64)
			if err != nil {
				valid = false
				log.Println(fmt.Sprintf("HTTP form input for field {{.NameWithLowerFirst}} %s is not an unsigned integer - %s", 
				    {{.NameWithLowerFirst}}Str, err.Error()))
				{{$resourceNameLower}}Form.SetErrorMessageForField("{{.NameWithUpperFirst}}", "must be a whole number >= 0")
			}
		{{else if eq .GoType "float64"}}
			{{.NameWithLowerFirst}}, err := strconv.ParseFloat({{.NameWithLowerFirst}}Str, 64)
			if err != nil {
				valid = false
				log.Println(fmt.Sprintf("HTTP form input for field {{.NameWithLowerFirst}} %s is not a float value - %s", 
					{{.NameWithLowerFirst}}Str, err.Error()))
				{{$resourceNameLower}}Form.SetErrorMessageForField("{{.NameWithUpperFirst}}", "must be a number")
			}
		{{else if eq .GoType "bool"}}
			{{.NameWithLowerFirst}} := false
			if len({{.NameWithLowerFirst}}Str) > 0 {
				{{.NameWithLowerFirst}}, err = strconv.ParseBool({{.NameWithLowerFirst}}Str)
				if err != nil {
					valid = false
					log.Println(fmt.Sprintf("HTTP form input for field {{.NameWithLowerFirst}} %s is not a bool - %s", 
					{{.NameWithLowerFirst}}Str, err.Error()))
					{{$resourceNameLower}}Form.SetErrorMessageForField("{{.NameWithUpperFirst}}", "must be true or false")
				}
			}
		{{end}}
	{{end}}
	{{$resourceNameLower}}.Set{{.NameWithUpperFirst}}({{.NameWithLowerFirst}})
{{end}}
	if valid {
		// The HTML form data is valid so far - check the mandatory string fields.
		{{$resourceNameLower}}Form.SetValid({{.NameWithLowerFirst}}Form.Validate())
	} else {
		// Syntax errors in the HTML form data.  Validate the mandatory string
		// fields to set any remaining error messages, but set the form invalid 
		// anyway.
		{{$resourceNameLower}}Form.Validate()
		{{$resourceNameLower}}Form.SetValid(false)
	}
	return {{.NameWithLowerFirst}}Form
}
{{end}}

// Recover from any panic and log an error.
func catchPanic() {
	if p := recover(); p != nil {
		log.Printf("unrecoverable internal error %v\n", p)
	}
}
