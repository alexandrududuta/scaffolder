{{$resourceNameLower := .NameWithLowerFirst}}
{{$resourceNameUpper := .NameWithUpperFirst}}
{{$resourceNamePluralUpper := .PluralNameWithUpperFirst}}
package {{.NameWithLowerFirst}}

{{.Imports}}

// Generated by the goblimey scaffold generator.  You are STRONGLY
// recommended not to alter this file, as it will be overwritten next time the 
// scaffolder is run.  For the same reason, do not commit this file to a 
// source code repository.  Commit the json specification which was used to 
// produce it.

// Unit tests for the {{.NameWithLowerFirst}} controller.  Uses mock objects
// created by pegomock.

var panicValue string

{{/* This creates the expected values using the field names and the test 
     values, something like:
	 var expectedName1 string = "s1"
	 var expectedAge1 int64 = 2 
	 var expectedName2 string = "s3"
	 var expectedAge2 int64 = 4 */}}
{{range $index, $element := .Fields}}
	{{if eq .Type "string"}}
		var expected{{.NameWithUpperFirst}}1 {{.GoType}} = "{{index .TestValues 0}}"
	{{else}}
		var expected{{.NameWithUpperFirst}}1 {{.GoType}} = {{index .TestValues 0}}
	{{end}}
	{{if eq .Type "string"}}
		var expected{{.NameWithUpperFirst}}2 {{.GoType}} = "{{index .TestValues 1}}"
	{{else}}
		var expected{{.NameWithUpperFirst}}2 {{.GoType}} = {{index .TestValues 1}}
	{{end}}
{{end}}

// TestUnitIndexWithOne{{.NameWithUpperFirst}} checks that the Index method of the 
// {{.NameWithLowerFirst}} controller handles a list of {{.PluralNameWithLowerFirst}} from FindAll() containing one {{.NameWithLowerFirst}}.
func TestUnitIndexWithOne{{.NameWithUpperFirst}}(t *testing.T) {

	var expectedID1 uint64 = 42
	
	pegomock.RegisterMockTestingT(t)

	// Create a list containing one {{.NameWithLowerFirst}}.
	expected{{.NameWithUpperFirst}}1 := {{.NameWithLowerFirst}}.MakeInitialised{{$resourceNameUpper}}(expectedID1, {{range .Fields}}expected{{.NameWithUpperFirst}}1{{if not .LastItem}}, {{end}}{{end}})
	expected{{.NameWithUpperFirst}}List := make([]{{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}, 1)
	expected{{.NameWithUpperFirst}}List[0] = expected{{.NameWithUpperFirst}}1

	// Create the mocks and dummy objects.
	var url url.URL
	url.Opaque = "/{{.PluralNameWithLowerFirst}}" // url.RequestURI() will return "/{{.PluralNameWithLowerFirst}}"
	var httpRequest http.Request
	httpRequest.URL = &url
	httpRequest.Method = "GET"
	var request restful.Request
	request.Request = &httpRequest
	writer := mocks.NewMockResponseWriter()
	var response restful.Response
	response.ResponseWriter = writer
	mockTemplate := mocks.NewMockTemplate()
	mockRepository := mock{{.NameWithUpperFirst}}.NewMockRepository()
	
	innerPageMap := make(map[string]retrofitTemplate.Template)
	innerPageMap["Index"] = mockTemplate
	pageMap := make(map[string]map[string]retrofitTemplate.Template)
	pageMap["{{.NameWithLowerFirst}}"] = innerPageMap

	// Create a service that returns the mock repository and templates.
	var services services.ConcreteServices
	services.Set{{.NameWithUpperFirst}}Repository(mockRepository)
	services.SetTemplates(&pageMap)

	// Create the form
	form := {{.NameWithLowerFirst}}Forms.MakeListForm()

	// Expect the controller to call the {{.NameWithLowerFirst}} repository's FindAll method.  Return
	// the list containing one {{.NameWithLowerFirst}}.
	pegomock.When(mockRepository.FindAll()).ThenReturn(expected{{.NameWithUpperFirst}}List, nil)
	
	// The request supplies method "GET" and URI "/{{.PluralNameWithLowerFirst}}".  Expect
	// template.Execute to be called and return nil (no error).
	pegomock.When(mockTemplate.Execute(writer, form)).ThenReturn(nil)

	// Run the test.
	var controller Controller
	controller.SetServices(&services)
	controller.Index(&request, &response, form)

	// We expect that the form contains the expected {{.NameWithLowerFirst}} list -
	// one {{.NameWithLowerFirst}} object with contents as expected.
	if form.{{.PluralNameWithUpperFirst}}() == nil {
		t.Errorf("Expected a list, got nil")
	}

	if len(form.{{.PluralNameWithUpperFirst}}()) != 1 {
		t.Errorf("Expected a list of 1, got %d", len(form.{{.PluralNameWithUpperFirst}}()))
	}

	if form.{{.PluralNameWithUpperFirst}}()[0].ID() != expectedID1 {
		t.Errorf("Expected ID %d, got %d",
			expectedID1, form.{{.PluralNameWithUpperFirst}}()[0].ID())
	}
{{range .Fields}}
	if form.{{$resourceNamePluralUpper}}()[0].{{.NameWithUpperFirst}}() != expected{{.NameWithUpperFirst}}1 {
		t.Errorf("Expected {{.NameWithLowerFirst}} %v, got %v",
			expected{{.NameWithUpperFirst}}1, form.{{$resourceNamePluralUpper}}()[0].{{.NameWithUpperFirst}}())
	}
{{end}}
}

// TestUnitIndexWithErrorWhenFetching{{.PluralNameWithUpperFirst}} checks that the {{.NameWithLowerFirst}} controller's
// Index() method handles errors from FindAll() correctly.
func TestUnitIndexWithErrorWhenFetching{{.PluralNameWithUpperFirst}}(t *testing.T) {

	log.SetPrefix("TestUnitIndexWithErrorWhenFetching{{.PluralNameWithUpperFirst}} ")
	log.Printf("This test is expected to provoke error messages in the log")

	expectedErr := errors.New("Test Error Message")
	expectedErrorMessage := "error getting the list of {{.PluralNameWithLowerFirst}} - Test Error Message"

	// Create the mocks and dummy objects.
	pegomock.RegisterMockTestingT(t)
	var url url.URL
	url.Opaque = "/{{.PluralNameWithLowerFirst}}" // url.RequestURI() will return "/{{.PluralNameWithLowerFirst}}"
	var httpRequest http.Request
	httpRequest.URL = &url
	httpRequest.Method = "GET"
	var request restful.Request
	request.Request = &httpRequest
	writer := mocks.NewMockResponseWriter()
	var response restful.Response
	response.ResponseWriter = writer
	mockTemplate := mocks.NewMockTemplate()
	mockRepository := mock{{.NameWithUpperFirst}}.NewMockRepository()
	
	// Create the form
	form := {{.NameWithLowerFirst}}Forms.MakeListForm()


	// Expect the controller to call the {{.NameWithLowerFirst}} repository's FindAll method.  Return
	// the list containing one {{.NameWithLowerFirst}}.
	pegomock.When(mockRepository.FindAll()).ThenReturn(nil, expectedErr)
	
	// Expect the controller to call the tenmplate's Execute() method.  Return
	// nil (no error).
	pegomock.When(mockTemplate.Execute(writer, form)).ThenReturn(nil)
	
	innerPageMap := make(map[string]retrofitTemplate.Template)
	innerPageMap["Index"] = mockTemplate
	pageMap := make(map[string]map[string]retrofitTemplate.Template)
	pageMap["{{.NameWithLowerFirst}}"] = innerPageMap

	// Create a service that returns the mock repository and templates.
	var services services.ConcreteServices
	services.Set{{.NameWithUpperFirst}}Repository(mockRepository)
	services.SetTemplates(&pageMap)

	// Create the controller and run the test.
	controller := MakeController(&services, false)
	controller.Index(&request, &response, form)

	// Verify that the form contains the expected error message.
	if form.ErrorMessage() != expectedErrorMessage {
		t.Errorf("Expected error message to be %s actually %s", expectedErrorMessage, form.ErrorMessage())
	}
}


// TestUnitIndexWithManyFailures checks that the {{.PluralNameWithUpperFirst}} controller's
// Index() method handles a series of errors correctly.
//
// Panic handling based on http://stackoverflow.com/questions/31595791/how-to-test-panics
//
func TestUnitIndexWithManyFailures(t *testing.T) {

	log.SetPrefix("TestUnitIndexWithManyFailures ")
	log.Printf("This test is expected to provoke error messages in the log")
	
	em1 := "first error message"

	expectedFirstErrorMessage := errors.New(em1)

	em2 := "second error message"
	expectedSecondErrorMessage := errors.New(em2)

	em3 := "final error message"
	finalErrorMessage := errors.New(em3)

	// Create the mocks and dummy objects.
	pegomock.RegisterMockTestingT(t)
	var url url.URL
	url.Opaque = "/{{.PluralNameWithLowerFirst}}" // url.RequestURI() will return "/{{.PluralNameWithLowerFirst}}"
	var httpRequest http.Request
	httpRequest.URL = &url
	httpRequest.Method = "GET"
	var request restful.Request
	request.Request = &httpRequest
	mockResponseWriter := mocks.NewMockResponseWriter()
	var response restful.Response
	response.ResponseWriter = mockResponseWriter
	mockIndexTemplate := mocks.NewMockTemplate()
	mockErrorTemplate := mocks.NewMockTemplate()
	mockRepository := mock{{.NameWithUpperFirst}}.NewMockRepository()
	
	// Create a template map containing the mock templates
	pageMap := make(map[string]map[string]retrofitTemplate.Template)
	pageMap["html"] = make(map[string]retrofitTemplate.Template)
	pageMap["html"]["Error"] = mockErrorTemplate
	pageMap["{{.NameWithLowerFirst}}"] = make(map[string]retrofitTemplate.Template)
	pageMap["{{.NameWithLowerFirst}}"]["Index"] = mockIndexTemplate

	// Create a service that returns the mock repository and templates.
	var services services.ConcreteServices
	services.Set{{.NameWithUpperFirst}}Repository(mockRepository)
	services.SetTemplates(&pageMap)

	// Create the form
	form := {{.NameWithLowerFirst}}Forms.MakeListForm()

	// Expectations:
	// Index will run List{{.PluralNameWithUpperFirst}} which will call the {{.NameWithLowerFirst}}
	// repository's FindAll().  Make that return an error, then List{{.PluralNameWithUpperFirst}} 
	// will get the Index page from the template and call its Execute method.  Make 
	// that fail, and the controller will get the error page and call its Execute 
	// method.  Make that fail and the app will panic with a message "fatal error - 
	// failed to display error page for error ", followed by the error message from 
	// the last Execute call.

	pegomock.When(mockRepository.FindAll()).ThenReturn(nil, 
		expectedFirstErrorMessage)
	pegomock.When(mockIndexTemplate.Execute(mockResponseWriter, form)).
		ThenReturn(expectedSecondErrorMessage)
	pegomock.When(mockErrorTemplate.Execute(mockResponseWriter, form)).
		ThenReturn(finalErrorMessage)

	// Expect a panic, catch it and check the value.  (If there is no panic,
	// this raises an error.)

	defer func() {
		r := recover()
		if r == nil {
			t.Errorf("Expected the Index call to panic")
		} else {
			em := fmt.Sprintf("%s", r)
			// Verify that the panic value is as expected.
			if !strings.Contains(em, em3) {
				t.Errorf("Expected a panic with value containing \"%s\" actually \"%s\"",
					em3, em)
			}
		}
	}()

	// Run the test.
	controller := MakeController(&services, false)
	controller.Index(&request, &response, form)

	// Verify that the form has an error message containing the expected text.
	if strings.Contains(form.ErrorMessage(), em1) {
		t.Errorf("Expected error message to be \"%s\" actually \"%s\"",
			expectedFirstErrorMessage, form.ErrorMessage())
	}

	// Verify that the list of {{.PluralNameWithLowerFirst}} is nil
	if form.{{.PluralNameWithUpperFirst}}() != nil {
		t.Errorf("Expected the list of {{.PluralNameWithLowerFirst}} to be nil.  Actually contains %d entries",
			len(form.{{.PluralNameWithUpperFirst}}()))
	}

}

// TestUnitSuccessfulCreate checks that the {{.NameWithLowerFirst}} controller's Create method
// correctly handles a successful attempt to create a {{.NameWithLowerFirst}} in the database.
func TestUnitSuccessfulCreate(t *testing.T) {

	log.SetPrefix("TestUnitSuccessfulCreate ")

	expectedNoticeFragment := "created {{.NameWithLowerFirst}}"
{{range .Fields}}
{{if not .ExcludeFromDisplay}}
{{if eq .Type "int"}}
	expected{{.NameWithUpperFirst}}1_str := fmt.Sprintf("%d", expected{{.NameWithUpperFirst}}1)
{{end}}
{{if eq .Type "float"}}
	expected{{.NameWithUpperFirst}}1_str := fmt.Sprintf("%f", expected{{.NameWithUpperFirst}}1)
{{end}}
{{if eq .Type "bool"}}
	expected{{.NameWithUpperFirst}}1_str := fmt.Sprintf("%v", expected{{.NameWithUpperFirst}}1)
{{end}}
{{end}}
{{end}}
	pegomock.RegisterMockTestingT(t)

	// Create the mocks and dummy objects.
	var expectedID1 uint64 = 42
	expected{{.NameWithUpperFirst}}1 := {{.NameWithLowerFirst}}.MakeInitialised{{$resourceNameUpper}}(expectedID1, {{range .Fields}}expected{{.NameWithUpperFirst}}1{{if not .LastItem}}, {{end}}{{end}})
	singleItemForm := {{.NameWithLowerFirst}}Forms.MakeInitialisedSingleItemForm(expected{{.NameWithUpperFirst}}1)
	listForm := {{.NameWithLowerFirst}}Forms.MakeListForm()
	{{.PluralNameWithLowerFirst}} := make([]{{.NameWithLowerFirst}}.{{.NameWithUpperFirst}}, 1)
	{{.PluralNameWithLowerFirst}}[0] = expected{{.NameWithUpperFirst}}1
	listForm.Set{{.PluralNameWithUpperFirst}}({{.PluralNameWithLowerFirst}})
	var url url.URL
	url.Opaque = "/{{.PluralNameWithLowerFirst}}/42" // url.RequestURI() will return "/{{.PluralNameWithLowerFirst}}/42"
	var httpRequest http.Request
	httpRequest.URL = &url
	httpRequest.Method = "POST"
	var request restful.Request
	request.Request = &httpRequest
	writer := mocks.NewMockResponseWriter()
	var response restful.Response
	response.ResponseWriter = writer
	mockIndexTemplate := mocks.NewMockTemplate()
	mockCreateTemplate := mocks.NewMockTemplate()
	mockRepository := mock{{.NameWithUpperFirst}}.NewMockRepository()
	mockServices := mocks.NewMockServices()

	// Create a template map containing the mock templates
	pageMap := make(map[string]map[string]retrofitTemplate.Template)
	pageMap["{{.NameWithLowerFirst}}"] = make(map[string]retrofitTemplate.Template)
	pageMap["{{.NameWithLowerFirst}}"]["Index"] = mockIndexTemplate
	pageMap["{{.NameWithLowerFirst}}"]["Create"] = mockCreateTemplate
	
	// Set expectations. The controller will display the Create template,
	// get some data, create a repository and use it to create a model object.
	// Then it will use the Index template to display the index page. 
	pegomock.When(mockServices.Template("{{.NameWithLowerFirst}}", "Create")).ThenReturn(mockCreateTemplate)
	pegomock.When(mockServices.{{.NameWithUpperFirst}}Repository()).ThenReturn(mockRepository)
	pegomock.When(mockRepository.Create(expected{{.NameWithUpperFirst}}1)).
		ThenReturn(expected{{.NameWithUpperFirst}}1, nil)
	pegomock.When(mockServices.Make{{.NameWithUpperFirst}}ListForm()).ThenReturn(listForm)
	pegomock.When(mockServices.Template("{{.NameWithLowerFirst}}", "Index")).ThenReturn(mockIndexTemplate)
	pegomock.When(mockRepository.FindAll()).ThenReturn({{.PluralNameWithLowerFirst}}, nil)
	pegomock.When(mockCreateTemplate.Execute(response.ResponseWriter, listForm)).
		ThenReturn(nil)

	// Run the test.
	controller := MakeController(mockServices, false)
	controller.Create(&request, &response, singleItemForm)

	// Verify that the form contains a notice with the expected contents.
	if !strings.Contains(listForm.Notice(), expectedNoticeFragment) {
		t.Errorf("Expected notice to contain \"%s\" actually \"%s\"",
			expectedNoticeFragment, listForm.Notice())
	}
{{range .Fields}}
{{if not .ExcludeFromDisplay}}
{{if eq .Type "string"}}
	if !strings.Contains(listForm.Notice(), expected{{.NameWithUpperFirst}}1) {
		t.Errorf("Expected notice to contain \"%s\" actually \"%s\"",
			expected{{.NameWithUpperFirst}}1, listForm.Notice())
	}
{{else}}
	if !strings.Contains(listForm.Notice(), expected{{.NameWithUpperFirst}}1_str) {
		t.Errorf("Expected notice to contain \"%s\" actually \"%s\"",
			expected{{.NameWithUpperFirst}}1_str, listForm.Notice())
	}
{{end}}
{{end}}
{{end}}
}

// TestUnitCreateFailsWithMissingFields checks that the {{.NameWithLowerFirst}} controller's 
// Create method correctly handles invalid data from the HTTP request.  Note: by 
// the time the code under test runs, number and boolean fields have already been 
// extracted from the HTML form and converted, so the only fields that can be made 
// invalid are mandatory string fields.  If there are none of those, the test will
// run successfully but it will do nothing useful.
// 
// The test uses pegomock to provide mocks.
func TestUnitCreateFailsWithMissingFields(t *testing.T) {

	log.SetPrefix("TestUnitCreateFailsWithMissingFields ")
{{range .Fields}}
	{{if and .Mandatory (eq .Type "string")}}
		expectedErrorMessage{{.NameWithUpperFirst}} := "you must specify the {{.NameWithLowerFirst}}"
	{{end}}
{{end}}
	pegomock.RegisterMockTestingT(t)
	
	var expectedID1 uint64 = 42
	// supply empty string for mandatory string fields, the given values for others.
	expected{{.NameWithUpperFirst}}1 := {{.NameWithLowerFirst}}.MakeInitialised{{$resourceNameUpper}}(expectedID1, {{range .Fields}}{{if and .Mandatory (eq .Type "string")}}"  "{{else}}expected{{.NameWithUpperFirst}}1{{end}}{{if not .LastItem}}, {{end}}{{end}})
	singleItemForm := {{.NameWithLowerFirst}}Forms.MakeInitialisedSingleItemForm(expected{{.NameWithUpperFirst}}1)

	// Create the mocks and dummy objects.
	
	var url url.URL
	url.Opaque = "/{{.PluralNameWithLowerFirst}}/42" // url.RequestURI() will return "/{{.PluralNameWithLowerFirst}}/42"
	var httpRequest http.Request
	httpRequest.URL = &url
	httpRequest.Method = "POST"
	var request restful.Request
	request.Request = &httpRequest
	writer := mocks.NewMockResponseWriter()
	var response restful.Response
	response.ResponseWriter = writer
	mockTemplate := mocks.NewMockTemplate()

	// Create a services layer that returns the mock create template.
	mockServices := mocks.NewMockServices()
	pegomock.When(mockServices.Template("{{.NameWithLowerFirst}}", "Create")).ThenReturn(mockTemplate)

	// Run the test.
	controller := MakeController(mockServices, false)

	controller.Create(&request, &response, singleItemForm)

	// If the {{.NameWithLowerFirst}} has mandatory string fields, verify that the 
	// form contains the expected error messages.
{{range .Fields}}
	{{if and .Mandatory (eq .Type "string")}}
		if singleItemForm.ErrorForField("{{.NameWithUpperFirst}}") != expectedErrorMessage{{.NameWithUpperFirst}} {
			t.Errorf("Expected error message to be %s actually %s",
				expectedErrorMessage{{.NameWithUpperFirst}}, singleItemForm.ErrorForField("{{.NameWithUpperFirst}}"))
		}
	{{end}}
{{end}}
}

// TestUnitCreateFailsWithDBError checks that the {{.NameWithLowerFirst}} handler's Create method
// correctly handles an error from the repository while attempting to create a
// {{.NameWithLowerFirst}} in the database.
func TestUnitCreateFailsWithDBError(t *testing.T) {

	log.SetPrefix("TestUnitCreateFailsWithDBError ")

	expectedErrorMessage := "some error"
	expectedErrorMessageLeader := "Could not create {{.NameWithLowerFirst}}"

	pegomock.RegisterMockTestingT(t)

	// Create the mocks and dummy objects.
	var expectedID1 uint64 = 42
	expected{{.NameWithUpperFirst}}1 := {{.NameWithLowerFirst}}.MakeInitialised{{$resourceNameUpper}}(expectedID1, {{range .Fields}}expected{{.NameWithUpperFirst}}1{{if not .LastItem}}, {{end}}{{end}})
	singleItemForm := {{.NameWithLowerFirst}}Forms.MakeInitialisedSingleItemForm(expected{{.NameWithUpperFirst}}1)
	listForm := {{.NameWithLowerFirst}}Forms.MakeListForm()
	var url url.URL
	url.Opaque = "/{{.PluralNameWithLowerFirst}}/42" // url.RequestURI() will return "/{{.PluralNameWithLowerFirst}}/42"
	var httpRequest http.Request
	httpRequest.URL = &url
	httpRequest.Method = "POST"
	var request restful.Request
	request.Request = &httpRequest
	writer := mocks.NewMockResponseWriter()
	var response restful.Response
	response.ResponseWriter = writer
	mockIndexTemplate := mocks.NewMockTemplate()
	mockCreateTemplate := mocks.NewMockTemplate()

	// Create a services layer that returns the mock create template.
	mockRepository := mock{{.NameWithUpperFirst}}.NewMockRepository()
	mockServices := mocks.NewMockServices()
	pegomock.When(mockServices.Template("{{.NameWithLowerFirst}}", "Create")).
		ThenReturn(mockCreateTemplate)
	pegomock.When(mockServices.{{.NameWithUpperFirst}}Repository()).ThenReturn(mockRepository)
	pegomock.When(mockRepository.Create(expected{{.NameWithUpperFirst}}1)).
		ThenReturn(nil, errors.New(expectedErrorMessage))
	pegomock.When(mockServices.Template("{{.NameWithLowerFirst}}", "Index")).
		ThenReturn(mockIndexTemplate)
	pegomock.When(mockServices.Make{{.NameWithUpperFirst}}ListForm()).ThenReturn(listForm)

	// Run the test.
	controller := MakeController(mockServices, false)

	controller.Create(&request, &response, singleItemForm)

	// Verify that the form contains the expected error message.
	if !strings.Contains(listForm.ErrorMessage(), expectedErrorMessageLeader) {
		t.Errorf("Expected error message to contain \"%s\" actually \"%s\"",
			expectedErrorMessageLeader, listForm.ErrorMessage())
	}

	if !strings.Contains(listForm.ErrorMessage(), expectedErrorMessage) {
		t.Errorf("Expected error message to contain \"%s\" actually \"%s\"",
			expectedErrorMessage, listForm.ErrorMessage())
	}
}

// Recover from any panic and record the error.
func catchPanic() {
	log.SetPrefix("catchPanic ")
	if p := recover(); p != nil {
		em := fmt.Sprintf("%v", p)
		panicValue = em
		log.Printf(em)
	}
}
