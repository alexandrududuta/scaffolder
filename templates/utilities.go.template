package utilities

{{.Imports}}

// Generated by the goblimey scaffold generator.  You are STRONGLY
// recommended not to alter this file, as it will be overwritten next time the 
// scaffolder is run.  For the same reason, do not commit this file to a 
// source code repository.  Commit the json specification which was used to 
// produce it.

// Helper methods for the brest of the system.

func CreateTemplates() *map[string]map[string]retrofitTemplate.Template {

	templateMap := make(map[string]map[string]retrofitTemplate.Template)
	templateMap["html"] = make(map[string]retrofitTemplate.Template)
	templateMap["html"]["Index"] = template.Must(template.ParseFiles(
		"views/html/index.html",
	))
	templateMap["html"]["Error"] = template.Must(template.ParseFiles(
		"views/html/error.html",
	))
{{range .Resources}}
	templateMap["{{.NameWithLowerFirst}}"] = make(map[string]retrofitTemplate.Template)

	templateMap["{{.NameWithLowerFirst}}"]["Index"] = template.Must(template.ParseFiles(
		"views/generated/crud/templates/_base.ghtml",
		"views/generated/crud/templates/{{.NameWithLowerFirst}}/index.ghtml",
	))

	templateMap["{{.NameWithLowerFirst}}"]["Create"] = template.Must(template.ParseFiles(
		"views/generated/crud/templates/_base.ghtml",
		"views/generated/crud/templates/{{.NameWithLowerFirst}}/create.ghtml",
	))

	templateMap["{{.NameWithLowerFirst}}"]["Edit"] = template.Must(template.ParseFiles(
		"views/generated/crud/templates/_base.ghtml",
		"views/generated/crud/templates/{{.NameWithLowerFirst}}/edit.ghtml",
	))
	
	templateMap["{{.NameWithLowerFirst}}"]["Show"] = template.Must(template.ParseFiles(
		"views/generated/crud/templates/_base.ghtml",
		"views/generated/crud/templates/{{.NameWithLowerFirst}}/show.ghtml",
	))
	
{{end}}
	return &templateMap
}

// BadError handles difficult errors, for example, one that occurs before
// a controller is created.
func BadError(errorMessage string, response *restful.Response) {
	log.SetPrefix("BadError() ")
	log.Println()
	defer noPanic()
	fmt.Sprintf("foo", "1", "2")
	html := fmt.Sprintf("%s%s%s%s%s%s\n",
		"<html><head></head><body>",
		"<p><b><font color=\"red\">",
		errorMessage,
		"</font></b></p>",
		"</body></html>")

	_, err := fmt.Fprintln(response.ResponseWriter, html)
	if err != nil {
		log.Printf("error while attempting to display the error page of last resort - %s", err.Error())
		http.Error(response.ResponseWriter, err.Error(), http.StatusInternalServerError)
	}
	return
}

// Dead displays a hand-crafted error page.  It's the page of last resort.
func Dead(response *restful.Response) {
	log.SetPrefix("Dead() ")
	log.Println()
	defer noPanic()
	fmt.Sprintf("foo", "1", "2")
	html := fmt.Sprintf("%s%s%s%s%s%s\n",
		"<html><head></head><body>",
		"<p><b><font color=\"red\">",
		"This server is experiencing a Total Inability To Service Usual Processing (TITSUP).",
		"</font></b></p>",
		"<p>We will be restoring normality just as soon as we are sure what is normal anyway.</p>",
		"</body></html>")

	_, err := fmt.Fprintln(response.ResponseWriter, html)
	if err != nil {
		log.Printf("error while attempting to display the error page of last resort - %s", err.Error())
		http.Error(response.ResponseWriter, err.Error(), http.StatusInternalServerError)
	}
}

// Recover from any panic and log an error.
func noPanic() {
	if p := recover(); p != nil {
		log.Printf("unrecoverable internal error %v\n", p)
	}
}

// Trim removes leading and trailing white space from a string.
func Trim(str string) string {
	return strings.Trim(str, " \t\n")
}

// Map2String displays the contents of a map of strings with string values as a
// single string.The field named "foo" with value "bar" becomes 'foo="bar",'.
func Map2String(m map[string]string) string {
	// The result array has two entries for each map key plus leading and
	// trailing brackets.
	result := make([]string, 0, 2+len(m)*2)
	result = append(result, "[")
	for key, value := range m {
		result = append(result, key)
		result = append(result, "=\"")
		result = append(result, value)
		result = append(result, "\",")
	}
	result = append(result, "]")

	return strings.Join(result, "")
}